                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
                        .area data(ram, con, rel)
 0000                   .dbfile ./main.c
 0000           _bytes_received::
 0000                   .blkb 1
                        .area idata
 0000 00                .byte 0
                        .area data(ram, con, rel)
 0001                   .dbfile ./main.c
 0001                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0001                   .dbsym e bytes_received _bytes_received c
 0001           _ext_mem_locked::
 0001                   .blkb 1
                        .area idata
 0001 00                .byte 0
                        .area data(ram, con, rel)
 0002                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0002                   .dbsym e ext_mem_locked _ext_mem_locked c
 0002           _m_to_s_offset::
 0002                   .blkb 1
                        .area idata
 0002 00                .byte 0
                        .area data(ram, con, rel)
 0003                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0003                   .dbsym e m_to_s_offset _m_to_s_offset c
 0003           _sin_value::
 0003                   .blkb 2
                        .area idata
 0003 0004              .word 4
                        .area data(ram, con, rel)
 0005                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0005                   .dbsym e sin_value _sin_value i
 0005           _cos_value::
 0005                   .blkb 2
                        .area idata
 0005 0005              .word 5
                        .area data(ram, con, rel)
 0007                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0007                   .dbsym e cos_value _cos_value i
 0007           _wait_cycle::
 0007                   .blkb 2
                        .area idata
 0007 0000              .word 0
                        .area data(ram, con, rel)
 0009                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0009                   .dbsym e wait_cycle _wait_cycle i
                        .area text(rom, con, rel)
 0000                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;              c -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3801              add SP,1
 0004                   .dbline 59
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>        // part specific constants and macros
 0004           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0004           ; 
 0004           ; unsigned char readMagEncConfig(void);
 0004           ; 
 0004           ; unsigned char target_address;
 0004           ; unsigned char bytes_received = 0;
 0004           ; unsigned char expected_bytes;
 0004           ; 
 0004           ; unsigned char ext_mem_locked = 0;
 0004           ; unsigned char m_to_s_offset = 0;
 0004           ; /********
 0004           ; m_to_s_memory map
 0004           ; 0:  Desired PWM duty cycle, channel 0
 0004           ; 1:  Desired PWM duty cycle, channel 1
 0004           ; 2:  Desired PWM duty cycle, channel 2
 0004           ; 3:  Desired PWM duty cycle, channel 3
 0004           ; 4:  Desired PWM duty cycle, channel 4
 0004           ; 5:  Desired PWM duty cycle, channel 5
 0004           ; ********/
 0004           ; unsigned char m_to_s_mem[32];
 0004           ; /********
 0004           ; s_to_m_memory map
 0004           ; 
 0004           ; ********/
 0004           ; unsigned char s_to_m_mem[32];
 0004           ; 
 0004           ; extern BYTE DELSIG8_bfStatus;
 0004           ; extern BYTE DELSIG8_cResult;
 0004           ; 
 0004           ; #define PWM_0_PORT    PRT0DR
 0004           ; #define PWM_0_PIN     0x80
 0004           ; #define NOTPWM_0_PIN 0x7F
 0004           ; #define SET_PWM_0   PWM_0_PORT |= PWM_0_PIN
 0004           ; #define UNSET_PWM_0 PWM_0_PORT &= NOTPWM_0_PIN
 0004           ; #define PWM_1_PORT    PRT0DR
 0004           ; #define PWM_1_PIN     0x20
 0004           ; #define PWM_2_PORT    PRT0DR
 0004           ; #define PWM_2_PIN     0x08
 0004           ; #define PWM_3_PORT    PRT0DR
 0004           ; #define PWM_3_PIN     0x02
 0004           ; #define PWM_4_PORT    PRT2DR
 0004           ; #define PWM_4_PIN     0x80
 0004           ; #define PWM_5_PORT    PRT2DR
 0004           ; #define PWM_5_PIN     0x20
 0004           ; 
 0004           ; #define ANALOG_MUX    AMX_IN    //  see datasheet pg 103
 0004           ; 
 0004           ; unsigned char pwm_count;
 0004           ; unsigned int sin_value = 4;
 0004           ; unsigned int cos_value = 5;
 0004           ; unsigned int wait_cycle = 0;
 0004           ; 
 0004           ; void main(void)
 0004           ; {
 0004                   .dbline 61
 0004           ;       // Insert your main routine code here.
 0004           ;       unsigned char c = 0;
 0004 560000            mov [X+0],0
 0007                   .dbline 62
 0007           ;       M8C_EnableGInt;
 0007 7101                      or  F, 01h
 0009           
 0009                   .dbline 63
 0009           ;       UART_EnableInt();
 0009 10                push X
 000A 7C0000            xcall _UART_EnableInt
 000D 20                pop X
 000E                   .dbline 64
 000E           ;       UART_Start(UART_PARITY_NONE);
 000E 10                push X
 000F 5000              mov A,0
 0011 7C0000            xcall _UART_Start
 0014 20                pop X
 0015                   .dbline 66
 0015           ; 
 0015           ;       PGA_1_Start(PGA_1_HIGHPOWER);
 0015 10                push X
 0016 5003              mov A,3
 0018 7C0000            xcall _PGA_1_Start
 001B 20                pop X
 001C                   .dbline 69
 001C           ; 
 001C           ;       //      void  ADCINC_Start (BYTE bPowerSetting)
 001C           ;       ADCINC_1_Start(3);
 001C 10                push X
 001D 5003              mov A,3
 001F 7C0000            xcall _ADCINC_1_Start
 0022 20                pop X
 0023                   .dbline 70
 0023           ;       ADCINC_1_GetSamples(0);
 0023 10                push X
 0024 5000              mov A,0
 0026 7C0000            xcall _ADCINC_1_GetSamples
 0029 20                pop X
 002A                   .dbline 71
 002A           ;       s_to_m_mem[0] = 1;
 002A 550101            mov [_s_to_m_mem],1
 002D                   .dbline 72
 002D           ;       s_to_m_mem[1] = 2;
 002D 550202            mov [_s_to_m_mem+1],2
 0030                   .dbline 74
 0030           ; 
 0030           ;       for (;;)
 0030           L3:
 0030                   .dbline 75
 0030           ;       {
 0030                   .dbline 79
 0030           ;       
 0030           ;       //  Set the Analog Mux to SIN
 0030           ;       //  Clear AMX_IN bit 0 to read SIN on P0[1] (header12 pin4)
 0030           ;               ANALOG_MUX &= 0xFE;
 0030 4160FE            and REG[0x60],-2
 0033                   .dbline 83
 0033           ;               
 0033           ;       //  Read the ADC value
 0033           ; 
 0033           ;               for(wait_cycle = 0; wait_cycle < 2; wait_cycle++)
 0033 550800            mov [_wait_cycle+1],0
 0036 550700            mov [_wait_cycle],0
 0039 801B              xjmp L10
 003B           L11:
 003B                   .dbline 86
 003B           ;               {
 003B           ;                       while(ADCINC_1_fIsDataAvailable() == 0)
 003B           ;                               ;
 003B           L12:
 003B                   .dbline 85
 003B 10                push X
 003C 7C0000            xcall _ADCINC_1_fIsDataAvailable
 003F 20                pop X
 0040 3900              cmp A,0
 0042 AFF8              jz L11
 0044                   .dbline 87
 0044           ;                       sin_value = ADCINC_1_wClearFlagGetData();   //  read garbage data while MUX settles
 0044 10                push X
 0045 7C0000            xcall _ADCINC_1_wClearFlagGetData
 0048 5A00              mov [__r0],X
 004A 20                pop X
 004B 5304              mov [_sin_value+1],A
 004D 5F0300            mov [_sin_value],[__r0]
 0050                   .dbline 88
 0050           ;               }
 0050           L8:
 0050                   .dbline 83
 0050 7608              inc [_wait_cycle+1]
 0052 0E0700            adc [_wait_cycle],0
 0055           L10:
 0055                   .dbline 83
 0055 5108              mov A,[_wait_cycle+1]
 0057 1102              sub A,2
 0059 5107              mov A,[_wait_cycle]
 005B 1900              sbb A,0
 005D CFDD              jc L12
 005F           X1:
 005F                   .dbline 98
 005F           ; 
 005F           ; //            while(ADCINC_1_fIsDataAvailable() == 0)
 005F           ; //                    ;
 005F           ;                       
 005F           ; //                    s_to_m_mem[0] = ADCINC_1_bClearFlagGetData();  //  for unsigned 8-bit data
 005F           ; //            sin_value = ADCINC_1_wClearFlagGetData();   //  for unsigned 16-bit data
 005F           ;               
 005F           ;       //  Set the Analog Mux to COS
 005F           ;       //  Set AMX_IN bit 0 to read COS on P0[3] (header12 pin3)
 005F           ;               ANALOG_MUX |= 0x01;
 005F 436001            or REG[0x60],1
 0062                   .dbline 101
 0062           ;       
 0062           ;       //  Read the ADC value
 0062           ;               for(wait_cycle = 0; wait_cycle < 2; wait_cycle++)
 0062 550800            mov [_wait_cycle+1],0
 0065 550700            mov [_wait_cycle],0
 0068 801B              xjmp L17
 006A           L18:
 006A                   .dbline 104
 006A           ;               {
 006A           ;                       while(ADCINC_1_fIsDataAvailable() == 0)
 006A           ;                               ;
 006A           L19:
 006A                   .dbline 103
 006A 10                push X
 006B 7C0000            xcall _ADCINC_1_fIsDataAvailable
 006E 20                pop X
 006F 3900              cmp A,0
 0071 AFF8              jz L18
 0073                   .dbline 105
 0073           ;                       cos_value = ADCINC_1_wClearFlagGetData();   //  read garbage data while MUX settles
 0073 10                push X
 0074 7C0000            xcall _ADCINC_1_wClearFlagGetData
 0077 5A00              mov [__r0],X
 0079 20                pop X
 007A 5306              mov [_cos_value+1],A
 007C 5F0500            mov [_cos_value],[__r0]
 007F                   .dbline 106
 007F           ;               }
 007F           L15:
 007F                   .dbline 101
 007F 7608              inc [_wait_cycle+1]
 0081 0E0700            adc [_wait_cycle],0
 0084           L17:
 0084                   .dbline 101
 0084 5108              mov A,[_wait_cycle+1]
 0086 1102              sub A,2
 0088 5107              mov A,[_wait_cycle]
 008A 1900              sbb A,0
 008C CFDD              jc L19
 008E           X2:
 008E                   .dbline 113
 008E           ; 
 008E           ; //            while(ADCINC_1_fIsDataAvailable() == 0)
 008E           ; //                    ;       
 008E           ; //                    s_to_m_mem[0] = ADCINC_1_bClearFlagGetData();  //  for unsigned 8-bit data
 008E           ; //            cos_value = ADCINC_1_wClearFlagGetData();   //  for unsigned 16-bit data
 008E           ;               
 008E           ;               s_to_m_mem[0] = (unsigned char)(sin_value >> 8);
 008E 5F0003            mov [__r1],[_sin_value]
 0091 5F0100            mov [_s_to_m_mem],[__r1]
 0094                   .dbline 114
 0094           ;               s_to_m_mem[1] = (unsigned char)(sin_value);
 0094 5F0004            mov [__r0],[_sin_value+1]
 0097 5F0200            mov [_s_to_m_mem+1],[__r0]
 009A                   .dbline 115
 009A           ;               s_to_m_mem[2] = (unsigned char)(cos_value >> 8);
 009A 5F0005            mov [__r1],[_cos_value]
 009D 5F0300            mov [_s_to_m_mem+2],[__r1]
 00A0                   .dbline 116
 00A0           ;               s_to_m_mem[3] = (unsigned char)(cos_value);
 00A0 5F0006            mov [__r0],[_cos_value+1]
 00A3 5F0400            mov [_s_to_m_mem+3],[__r0]
 00A6                   .dbline 117
 00A6           ;       }
 00A6                   .dbline 74
 00A6                   .dbline 74
 00A6 8F89              xjmp L3
 00A8           X0:
 00A8                   .dbline -2
 00A8           L1:
 00A8 38FF              add SP,-1
 00AA 20                pop X
 00AB                   .dbline 0 ; func end
 00AB 8FFF              jmp .
 00AD                   .dbsym l c 0 c
 00AD                   .dbend
 00AD                   .dbfunc e readMagEncConfig _readMagEncConfig fc
 00AD           ;   write_config -> X+8
 00AD           ;      bitnumber -> X+7
 00AD           ;       tx_value -> X+6
 00AD           ;    read_config -> X+5
 00AD           ;   DIO_bit_mask -> X+4
 00AD           ;        counter -> X+2
 00AD           ; ssi_clk_half_period -> X+1
 00AD           ;    clk_counter -> X+0
 00AD           _readMagEncConfig::
 00AD                   .dbline -1
 00AD 10                push X
 00AE 4F                mov X,SP
 00AF 3809              add SP,9
 00B1                   .dbline 165
 00B1           ; 
 00B1           ; /*
 00B1           ;       for(pwm_count = 0; 1; pwm_count++)
 00B1           ;       {
 00B1           ;               if( pwm_count < m_to_s_mem[0] )
 00B1           ;                       PWM_0_PORT |=  PWM_0_PIN;
 00B1           ;               else
 00B1           ;                       PWM_0_PORT &= ~PWM_0_PIN;
 00B1           ;               if( pwm_count < m_to_s_mem[1] )
 00B1           ;                       PWM_1_PORT |=  PWM_1_PIN;
 00B1           ;               else
 00B1           ;                       PWM_1_PORT &= ~PWM_1_PIN;
 00B1           ;               if( pwm_count < m_to_s_mem[2] )
 00B1           ;                       PWM_2_PORT |=  PWM_2_PIN;
 00B1           ;               else
 00B1           ;                       PWM_2_PORT &= ~PWM_2_PIN;
 00B1           ;               if( pwm_count < m_to_s_mem[3] )
 00B1           ;                       PWM_3_PORT |=  PWM_3_PIN;
 00B1           ;               else
 00B1           ;                       PWM_3_PORT &= ~PWM_3_PIN;
 00B1           ;               if( pwm_count < m_to_s_mem[4] )
 00B1           ;                       PWM_4_PORT |=  PWM_4_PIN;
 00B1           ;               else
 00B1           ;                       PWM_4_PORT &= ~PWM_4_PIN;
 00B1           ;               if( pwm_count < m_to_s_mem[5] )
 00B1           ;                       PWM_5_PORT |=  PWM_5_PIN;
 00B1           ;               else
 00B1           ;                       PWM_5_PORT &= ~PWM_5_PIN;
 00B1           ;               if(pwm_count == 16)
 00B1           ;                       pwm_count = 0; 
 00B1           ;       }
 00B1           ;       */
 00B1           ;       /*
 00B1           ;       for (read_count = 0; 1; read_count++)
 00B1           ;       {
 00B1           ;               if (read_count == 10000)
 00B1           ;               {
 00B1           ;                       read_count = 0;
 00B1           ;                       s_to_m_mem[0] = readMagEncConfig();
 00B1           ;               }
 00B1           ;       }
 00B1           ;       */
 00B1           ; }
 00B1           ; 
 00B1           ; 
 00B1           ; 
 00B1           ; unsigned char readMagEncConfig(void)
 00B1           ; {
 00B1                   .dbline 177
 00B1           ; //  read config from AustriaMicroSystems SSI
 00B1           ; #define SSI_PORT      PRT1DR  //  Port 1, pins 3, 5 and 7
 00B1           ; #define SSI_CS_PIN    0x08
 00B1           ; #define SSI_DCLK_PIN  0x20
 00B1           ; #define SSI_DIO_PIN   0x80
 00B1           ; 
 00B1           ; //    see datasheet pg59                      Resistive pullup        Strong Drive
 00B1           ; // #define SSI_PORT  PRT1DM2  0                                       0
 00B1           ; // #define SSI_PORT  PRD1DM1  1                                       0
 00B1           ; // #define SSI_PORT  PRD1DM0  1                                       1
 00B1           ; 
 00B1           ; unsigned char clk_counter=0;
 00B1 560000            mov [X+0],0
 00B4                   .dbline 178
 00B4           ; unsigned char bitnumber=0;
 00B4 560700            mov [X+7],0
 00B7                   .dbline 180
 00B7           ; int counter;
 00B7           ; unsigned char DIO_bit_mask = 128;
 00B7 560480            mov [X+4],-128
 00BA                   .dbline 182
 00BA           ; 
 00BA           ; unsigned char ssi_clk_half_period = 10;
 00BA 56010A            mov [X+1],10
 00BD                   .dbline 183
 00BD           ; unsigned char read_config = 0b00000111;
 00BD 560507            mov [X+5],7
 00C0                   .dbline 184
 00C0           ; unsigned char write_config = 0b00010111;
 00C0 560817            mov [X+8],23
 00C3                   .dbline 186
 00C3           ; 
 00C3           ; unsigned char tx_value = 0;
 00C3 560600            mov [X+6],0
 00C6                   .dbline 191
 00C6           ; 
 00C6           ; //  raise chip select to begin communicating
 00C6           ; //  first clear the clock and IO pins
 00C6           ; 
 00C6           ; SSI_PORT &= ~SSI_CS_PIN;
 00C6 4104F7            and REG[0x4],-9
 00C9                   .dbline 192
 00C9           ; SSI_PORT &= ~SSI_DCLK_PIN;
 00C9 4104DF            and REG[0x4],-33
 00CC                   .dbline 193
 00CC           ; SSI_PORT &= ~SSI_DIO_PIN;
 00CC 41047F            and REG[0x4],127
 00CF                   .dbline 197
 00CF           ; 
 00CF           ; //  raise the CS pin
 00CF           ; 
 00CF           ; SSI_PORT |= SSI_CS_PIN;
 00CF 430408            or REG[0x4],8
 00D2                   .dbline 201
 00D2           ; 
 00D2           ; //  transmit the "read config" command, the read config code is (I think) 00111
 00D2           ; 
 00D2           ; for (counter = 4; counter >= 0; counter--)
 00D2 560304            mov [X+3],4
 00D5 560200            mov [X+2],0
 00D8           L25:
 00D8                   .dbline 202
 00D8           ;       {
 00D8                   .dbline 205
 00D8           ;       //  set DIO value
 00D8           ;       
 00D8           ;       DIO_bit_mask = 1 << counter;  // move down through the transmit values
 00D8 550001            mov [__r1],1
 00DB 550000            mov [__r0],0
 00DE 5203              mov A,[X+3]
 00E0 210F              and A,15
 00E2 A008              jz X3
 00E4           X4:
 00E4 6500              asl [__r1]
 00E6 6B00              rlc [__r0]
 00E8 78                dec A
 00E9 BFFA              jnz X4
 00EB           X3:
 00EB 5100              mov A,[__r1]
 00ED 5404              mov [X+4],A
 00EF                   .dbline 207
 00EF           ; 
 00EF           ;       if (read_config && DIO_bit_mask)
 00EF 3D0500            cmp [X+5],0
 00F2 A00B              jz L29
 00F4 3D0400            cmp [X+4],0
 00F7 A006              jz L29
 00F9                   .dbline 208
 00F9           ;               {
 00F9                   .dbline 209
 00F9           ;               SSI_PORT |= SSI_DIO_PIN;        // set SSI DIO_PIN;
 00F9 430480            or REG[0x4],-128
 00FC                   .dbline 210
 00FC           ;               }
 00FC 8008              xjmp L32
 00FE           L29:
 00FE                   .dbline 212
 00FE           ;       else
 00FE           ;               {
 00FE                   .dbline 213
 00FE           ;               SSI_PORT &= ~SSI_DIO_PIN;  // clear SSI_DIO_PIN
 00FE 41047F            and REG[0x4],127
 0101                   .dbline 214
 0101           ;               }
 0101 8003              xjmp L32
 0103           L31:
 0103                   .dbline 218
 0103           ;                       
 0103           ;       //  wait half the clock cycle
 0103           ;       while(clk_counter < ssi_clk_half_period)
 0103           ;               clk_counter++;
 0103 7700              inc [X+0]
 0105           L32:
 0105                   .dbline 217
 0105 5200              mov A,[X+0]
 0107 3B01              cmp A,[X+1]
 0109 CFF9              jc L31
 010B           X5:
 010B                   .dbline 219
 010B           ;       clk_counter = 0;        
 010B 560000            mov [X+0],0
 010E                   .dbline 222
 010E           ;       
 010E           ;       //  raise DCLK
 010E           ;       SSI_PORT |= SSI_DCLK_PIN;
 010E 430420            or REG[0x4],32
 0111 8003              xjmp L35
 0113           L34:
 0113                   .dbline 226
 0113           ;       
 0113           ;       //  wait half the clock cycle
 0113           ;       while(clk_counter < ssi_clk_half_period)
 0113           ;               clk_counter++;
 0113 7700              inc [X+0]
 0115           L35:
 0115                   .dbline 225
 0115 5200              mov A,[X+0]
 0117 3B01              cmp A,[X+1]
 0119 CFF9              jc L34
 011B           X6:
 011B                   .dbline 227
 011B           ;       clk_counter = 0;        
 011B 560000            mov [X+0],0
 011E                   .dbline 230
 011E           ;       
 011E           ;       //  lower DCLK
 011E           ;       SSI_PORT &= ~SSI_DCLK_PIN;
 011E 4104DF            and REG[0x4],-33
 0121                   .dbline 232
 0121           ;       
 0121           ;       }
 0121           L26:
 0121                   .dbline 201
 0121 7B03              dec [X+3]
 0123 1F0200            sbb [X+2],0
 0126                   .dbline 201
 0126 5203              mov A,[X+3]
 0128 1100              sub A,0
 012A 5202              mov A,[X+2]
 012C 3180              xor A,-128
 012E 1980              sbb A,(0 ^ 0x80)
 0130 DFA7              jnc L25
 0132           X7:
 0132                   .dbline 240
 0132           ; 
 0132           ; 
 0132           ; //  the write config code is 10111
 0132           ; 
 0132           ; //  the remaining 16 bits are read from or written to the peripheral chip
 0132           ; 
 0132           ; 
 0132           ; for (counter = 15; counter >= 0; counter--)
 0132 56030F            mov [X+3],15
 0135 560200            mov [X+2],0
 0138           L37:
 0138                   .dbline 241
 0138           ;       {
 0138                   .dbline 244
 0138           ;       //  clear DIO value, or switch to input mode?
 0138           ;       
 0138           ;       DIO_bit_mask = 1 << counter;  // move down through the transmit values
 0138 550001            mov [__r1],1
 013B 550000            mov [__r0],0
 013E 5203              mov A,[X+3]
 0140 210F              and A,15
 0142 A008              jz X8
 0144           X9:
 0144 6500              asl [__r1]
 0146 6B00              rlc [__r0]
 0148 78                dec A
 0149 BFFA              jnz X9
 014B           X8:
 014B 5100              mov A,[__r1]
 014D 5404              mov [X+4],A
 014F 8003              xjmp L42
 0151           L41:
 0151                   .dbline 248
 0151           ;                       
 0151           ;       //  wait half the clock cycle
 0151           ;       while(clk_counter < ssi_clk_half_period)
 0151           ;               clk_counter++;
 0151 7700              inc [X+0]
 0153           L42:
 0153                   .dbline 247
 0153 5200              mov A,[X+0]
 0155 3B01              cmp A,[X+1]
 0157 CFF9              jc L41
 0159           X10:
 0159                   .dbline 249
 0159           ;       clk_counter = 0;        
 0159 560000            mov [X+0],0
 015C                   .dbline 252
 015C           ;       
 015C           ;       //  raise DCLK
 015C           ;       SSI_PORT |= SSI_DCLK_PIN;
 015C 430420            or REG[0x4],32
 015F                   .dbline 254
 015F           ; 
 015F           ;       if (SSI_PORT && SSI_DIO_PIN)  // if the input value is high, set tx_value bit.
 015F 5D04              mov A,REG[0x4]
 0161 3900              cmp A,0
 0163 A00B              jz L47
 0165                   .dbline 255
 0165           ;               tx_value |= DIO_bit_mask;
 0165 5206              mov A,[X+6]
 0167 2B04              or A,[X+4]
 0169 5406              mov [X+6],A
 016B 8003              xjmp L47
 016D           L46:
 016D                   .dbline 259
 016D           ;       
 016D           ;       //  wait half the clock cycle
 016D           ;       while(clk_counter < ssi_clk_half_period)
 016D           ;               clk_counter++;
 016D 7700              inc [X+0]
 016F           L47:
 016F                   .dbline 258
 016F 5200              mov A,[X+0]
 0171 3B01              cmp A,[X+1]
 0173 CFF9              jc L46
 0175           X11:
 0175                   .dbline 260
 0175           ;       clk_counter = 0;        
 0175 560000            mov [X+0],0
 0178                   .dbline 263
 0178           ;       
 0178           ;       //  lower DCLK
 0178           ;       SSI_PORT &= ~SSI_DCLK_PIN;
 0178 4104DF            and REG[0x4],-33
 017B                   .dbline 265
 017B           ;       
 017B           ;       }
 017B           L38:
 017B                   .dbline 240
 017B 7B03              dec [X+3]
 017D 1F0200            sbb [X+2],0
 0180                   .dbline 240
 0180 5203              mov A,[X+3]
 0182 1100              sub A,0
 0184 5202              mov A,[X+2]
 0186 3180              xor A,-128
 0188 1980              sbb A,(0 ^ 0x80)
 018A DFAD              jnc L37
 018C           X12:
 018C                   .dbline 267
 018C           ; 
 018C           ; return tx_value;
 018C 5206              mov A,[X+6]
 018E                   .dbline -2
 018E           L24:
 018E 38F7              add SP,-9
 0190 20                pop X
 0191                   .dbline 0 ; func end
 0191 7F                ret
 0192                   .dbsym l write_config 8 c
 0192                   .dbsym l bitnumber 7 c
 0192                   .dbsym l tx_value 6 c
 0192                   .dbsym l read_config 5 c
 0192                   .dbsym l DIO_bit_mask 4 c
 0192                   .dbsym l counter 2 I
 0192                   .dbsym l ssi_clk_half_period 1 c
 0192                   .dbsym l clk_counter 0 c
 0192                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile C:\DOCUME~1\ADMINI~1\MYDOCU~1\hexapod\MAGNET~1\MAGNET~1\MAGNET~1\main.c
 0000           _pwm_count::
 0000                   .blkb 1
 0001                   .dbsym e pwm_count _pwm_count c
 0001           _s_to_m_mem::
 0001                   .blkb 32
 0021                   .dbsym e s_to_m_mem _s_to_m_mem A[32:32]c
 0021           _m_to_s_mem::
 0021                   .blkb 32
 0041                   .dbsym e m_to_s_mem _m_to_s_mem A[32:32]c
 0041           _expected_bytes::
 0041                   .blkb 1
 0042                   .dbsym e expected_bytes _expected_bytes c
 0042           _target_address::
 0042                   .blkb 1
 0043                   .dbsym e target_address _target_address c
